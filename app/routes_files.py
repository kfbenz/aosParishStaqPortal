"""
File Management Routes for ParishStaq Portal

Provides file upload, download, and browsing functionality for:
- Reports generated by the system
- Data exports (CSV, Excel)
- User uploaded files

Author: Kevin Benz - Archdiocese of Seattle IT
Date: December 2024
"""

import os
import re
from datetime import datetime
from pathlib import Path
from typing import Optional

from fastapi import APIRouter, Request, UploadFile, File, Form, Depends, HTTPException
from fastapi.responses import HTMLResponse, RedirectResponse, FileResponse
from fastapi.templating import Jinja2Templates

from .auth import get_current_user, require_admin

router = APIRouter(prefix="/files", tags=["Files"])

# Templates
templates_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "templates")
templates = Jinja2Templates(directory=templates_path)

# File directories
BASE_DIR = "/opt/portal_app/aosParishStaq"
DIRECTORIES = {
    "Reports": os.path.join(BASE_DIR, "Reports"),
    "Data": os.path.join(BASE_DIR, "Data"),
    "Uploads": os.path.join(BASE_DIR, "Data/uploads"),
    "Exports": os.path.join(BASE_DIR, "Data/exports"),
}

# Allowed extensions for upload
ALLOWED_EXTENSIONS = {'.csv', '.xlsx', '.xls', '.json', '.txt', '.pdf', '.zip', '.xml'}

# Max upload size (50 MB)
MAX_UPLOAD_SIZE = 50 * 1024 * 1024


def secure_filename(filename: str) -> str:
    """Sanitize filename to prevent path traversal"""
    # Remove path components
    filename = os.path.basename(filename)
    # Replace spaces and special chars but keep unicode letters
    filename = re.sub(r'[<>:"/\\|?*\x00-\x1f]', '', filename)
    filename = re.sub(r'\s+', '_', filename)
    return filename


def get_file_icon(filename: str) -> str:
    """Get Bootstrap icon class based on file extension"""
    ext = Path(filename).suffix.lower()
    icons = {
        '.csv': 'bi-filetype-csv',
        '.xlsx': 'bi-file-earmark-excel',
        '.xls': 'bi-file-earmark-excel',
        '.json': 'bi-filetype-json',
        '.txt': 'bi-file-earmark-text',
        '.pdf': 'bi-file-earmark-pdf',
        '.zip': 'bi-file-earmark-zip',
        '.html': 'bi-filetype-html',
        '.xml': 'bi-filetype-xml',
    }
    return icons.get(ext, 'bi-file-earmark')


def format_size(size_bytes: int) -> str:
    """Format file size in human readable format"""
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.1f} KB"
    else:
        return f"{size_bytes / (1024 * 1024):.1f} MB"


def get_files_in_directory(directory: str, folder_name: str) -> list:
    """Get list of files in a directory with metadata"""
    files = []
    
    if not os.path.exists(directory):
        return files
    
    for filename in os.listdir(directory):
        filepath = os.path.join(directory, filename)
        
        # Skip directories and hidden files
        if os.path.isdir(filepath) or filename.startswith('.'):
            continue
        
        try:
            stat = os.stat(filepath)
            files.append({
                "name": filename,
                "folder": folder_name,
                "path": f"{folder_name}/{filename}",
                "size": stat.st_size,
                "size_formatted": format_size(stat.st_size),
                "modified": datetime.fromtimestamp(stat.st_mtime),
                "icon": get_file_icon(filename),
                "extension": Path(filename).suffix.lower()
            })
        except OSError:
            continue
    
    return files


def read_file_with_fallback(file_path: str, max_bytes: int = 50000) -> tuple:
    """
    Read file content with encoding fallback.
    Returns (content, encoding_used)
    """
    encodings = ['utf-8', 'utf-8-sig', 'latin-1', 'cp1252', 'iso-8859-1']
    
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                content = f.read(max_bytes)
                if len(content) == max_bytes:
                    content += "\n\n... (truncated)"
                return content, encoding
        except UnicodeDecodeError:
            continue
        except Exception as e:
            return f"Error reading file: {e}", None
    
    # If all text encodings fail, try reading as binary and decode lossy
    try:
        with open(file_path, 'rb') as f:
            raw = f.read(max_bytes)
            content = raw.decode('utf-8', errors='replace')
            if len(raw) == max_bytes:
                content += "\n\n... (truncated)"
            return content, 'binary (lossy)'
    except Exception as e:
        return f"Cannot read file: {e}", None


@router.get("/", response_class=HTMLResponse)
async def files_home(request: Request):
    """File browser home page"""
    user = get_current_user(request)
    if not user:
        return RedirectResponse(url="/auth/login", status_code=303)
    
    # Get files from all directories
    all_files = []
    folder_stats = {}
    
    for folder_name, directory in DIRECTORIES.items():
        # Ensure directory exists
        os.makedirs(directory, exist_ok=True)
        
        files = get_files_in_directory(directory, folder_name)
        all_files.extend(files)
        
        folder_stats[folder_name] = {
            "count": len(files),
            "size": sum(f["size"] for f in files)
        }
    
    # Sort by modified date (newest first)
    all_files.sort(key=lambda x: x['modified'], reverse=True)
    
    return templates.TemplateResponse("files/index.html", {
        "request": request,
        "user": user,
        "files": all_files,
        "folder_stats": folder_stats,
        "folders": list(DIRECTORIES.keys())
    })


@router.get("/browse/{folder}", response_class=HTMLResponse)
async def browse_folder(request: Request, folder: str):
    """Browse files in a specific folder"""
    user = get_current_user(request)
    if not user:
        return RedirectResponse(url="/auth/login", status_code=303)
    
    if folder not in DIRECTORIES:
        return RedirectResponse(url="/files", status_code=303)
    
    directory = DIRECTORIES[folder]
    os.makedirs(directory, exist_ok=True)
    
    files = get_files_in_directory(directory, folder)
    files.sort(key=lambda x: x['modified'], reverse=True)
    
    return templates.TemplateResponse("files/browse.html", {
        "request": request,
        "user": user,
        "files": files,
        "folder": folder,
        "folders": list(DIRECTORIES.keys())
    })


@router.get("/download/{folder}/{filename}")
async def download_file(request: Request, folder: str, filename: str):
    """Download a file"""
    user = get_current_user(request)
    if not user:
        raise HTTPException(status_code=401, detail="Not authenticated")
    
    # Validate folder
    if folder not in DIRECTORIES:
        raise HTTPException(status_code=404, detail="Folder not found")
    
    # Prevent path traversal
    safe_name = secure_filename(filename)
    file_path = os.path.join(DIRECTORIES[folder], safe_name)
    
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="File not found")
    
    # Determine media type
    ext = Path(safe_name).suffix.lower()
    media_types = {
        '.csv': 'text/csv',
        '.json': 'application/json',
        '.txt': 'text/plain',
        '.pdf': 'application/pdf',
        '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        '.xls': 'application/vnd.ms-excel',
        '.zip': 'application/zip',
        '.html': 'text/html',
        '.xml': 'application/xml',
    }
    media_type = media_types.get(ext, 'application/octet-stream')
    
    return FileResponse(
        file_path,
        filename=safe_name,
        media_type=media_type
    )


@router.get("/upload", response_class=HTMLResponse)
async def upload_form(request: Request, user: dict = Depends(require_admin)):
    """Upload file form"""
    return templates.TemplateResponse("files/upload.html", {
        "request": request,
        "user": user,
        "allowed_extensions": ", ".join(sorted(ALLOWED_EXTENSIONS)),
        "max_size_mb": MAX_UPLOAD_SIZE / (1024 * 1024)
    })


@router.post("/upload")
async def upload_file(
    request: Request,
    file: UploadFile = File(...),
    destination: str = Form("Uploads"),
    user: dict = Depends(require_admin)
):
    """Handle file upload - binary safe for all encodings"""
    
    # Validate destination folder
    if destination not in DIRECTORIES:
        destination = "Uploads"
    
    upload_dir = DIRECTORIES[destination]
    os.makedirs(upload_dir, exist_ok=True)
    
    # Validate file extension
    ext = Path(file.filename).suffix.lower()
    if ext not in ALLOWED_EXTENSIONS:
        return templates.TemplateResponse("files/upload.html", {
            "request": request,
            "user": user,
            "error": f"File type '{ext}' not allowed. Allowed: {', '.join(sorted(ALLOWED_EXTENSIONS))}",
            "allowed_extensions": ", ".join(sorted(ALLOWED_EXTENSIONS)),
            "max_size_mb": MAX_UPLOAD_SIZE / (1024 * 1024)
        })
    
    # Sanitize filename
    safe_name = secure_filename(file.filename)
    if not safe_name:
        safe_name = f"upload_{datetime.now().strftime('%Y%m%d_%H%M%S')}{ext}"
    
    file_path = os.path.join(upload_dir, safe_name)
    
    # Check if file exists - add timestamp if so
    if os.path.exists(file_path):
        base = Path(safe_name).stem
        safe_name = f"{base}_{datetime.now().strftime('%Y%m%d_%H%M%S')}{ext}"
        file_path = os.path.join(upload_dir, safe_name)
    
    # Read file as binary (preserves all encodings)
    contents = await file.read()
    
    # Validate size
    if len(contents) > MAX_UPLOAD_SIZE:
        return templates.TemplateResponse("files/upload.html", {
            "request": request,
            "user": user,
            "error": f"File too large ({format_size(len(contents))}). Maximum size is {MAX_UPLOAD_SIZE / (1024*1024):.0f} MB",
            "allowed_extensions": ", ".join(sorted(ALLOWED_EXTENSIONS)),
            "max_size_mb": MAX_UPLOAD_SIZE / (1024 * 1024)
        })
    
    # Write file as binary (preserves exact bytes/encoding)
    with open(file_path, "wb") as f:
        f.write(contents)
    
    return RedirectResponse(
        url=f"/files/browse/{destination}?success=File '{safe_name}' uploaded successfully ({format_size(len(contents))})",
        status_code=303
    )


@router.post("/delete/{folder}/{filename}")
async def delete_file(
    request: Request,
    folder: str,
    filename: str,
    user: dict = Depends(require_admin)
):
    """Delete a file"""
    
    # Validate folder
    if folder not in DIRECTORIES:
        raise HTTPException(status_code=404, detail="Folder not found")
    
    # Prevent path traversal
    safe_name = secure_filename(filename)
    file_path = os.path.join(DIRECTORIES[folder], safe_name)
    
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="File not found")
    
    try:
        os.remove(file_path)
        return RedirectResponse(
            url=f"/files/browse/{folder}?success=File '{safe_name}' deleted",
            status_code=303
        )
    except OSError as e:
        return RedirectResponse(
            url=f"/files/browse/{folder}?error=Could not delete file: {e}",
            status_code=303
        )


@router.get("/preview/{folder}/{filename}", response_class=HTMLResponse)
async def preview_file(request: Request, folder: str, filename: str):
    """Preview file contents (for text-based files)"""
    user = get_current_user(request)
    if not user:
        return RedirectResponse(url="/auth/login", status_code=303)
    
    if folder not in DIRECTORIES:
        raise HTTPException(status_code=404, detail="Folder not found")
    
    safe_name = secure_filename(filename)
    file_path = os.path.join(DIRECTORIES[folder], safe_name)
    
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="File not found")
    
    ext = Path(safe_name).suffix.lower()
    previewable = {'.csv', '.txt', '.json', '.html', '.xml'}
    
    content = None
    preview_type = "text"
    encoding_used = None
    
    if ext in previewable:
        content, encoding_used = read_file_with_fallback(file_path)
        
        if ext == '.csv':
            preview_type = "csv"
        elif ext == '.json':
            preview_type = "json"
        elif ext == '.html':
            preview_type = "html"
        elif ext == '.xml':
            preview_type = "xml"
    else:
        content = f"Preview not available for {ext} files. Please download to view."
    
    stat = os.stat(file_path)
    
    return templates.TemplateResponse("files/preview.html", {
        "request": request,
        "user": user,
        "filename": safe_name,
        "folder": folder,
        "content": content,
        "preview_type": preview_type,
        "encoding": encoding_used,
        "size": format_size(stat.st_size),
        "modified": datetime.fromtimestamp(stat.st_mtime)
    })
